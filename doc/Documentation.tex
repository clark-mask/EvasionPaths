\documentclass[12pt]{article}

\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{amsthm}

\usepackage[dvipsnames, table]{xcolor}
\colorlet{DarkRed}{Red!90!black}
\colorlet{LightRed}{Red!10!white}
\colorlet{DarkGreen}{Green!50!black}
\colorlet{LightGreen}{Green!10!white}
\usepackage{colortbl} % https://texblog.org/2011/04/19/highlight-table-rowscolumns-with-color/

% sections
\usepackage{titlesec} % https://latex.org/forum/viewtopic.php?t=10456
\titleformat*{\section}{\large\bfseries}
\titlespacing*{\section}{0pt}{2mm}{2mm}
\titleformat{\subsection}[runin]% runin puts it in the same paragraph
{\normalfont\bfseries}% formatting commands to apply to the whole heading
{\thesubsection}% the label and number
{0.5em}% space between label/number and subsection title
{}% formatting commands applied just to subsection title
[.]% punctuation or other commands following subsection title
%\titleformat{\section}[runin]{\normalfont\bfseries}{\thesection}{0.5em}{}[.]
\titleformat{\subsubsection}[runin]{\normalfont\bfseries}{\thesubsubsection}{0.5em}{}[.]

% links
\usepackage{hyperref}
\hypersetup{
	colorlinks,
	linkcolor={DarkRed},
	citecolor={DarkRed},
	urlcolor={blue}
}

\usepackage{geometry}
\newgeometry{
	left=2cm, right=1.5cm, top=1.5cm, bottom=1.5cm,
	includefoot, heightrounded
}

\usepackage[parfill]{parskip} % https://tex.stackexchange.com/a/16703/135296

% sub figures / grids of pictures
\usepackage{pdfpages}
\usepackage{subcaption}
\usepackage{graphicx}
\graphicspath{{img/}} % includegraphics path
% \usepackage[export]{adjustbox} % https://tex.stackexchange.com/questions/20640/how-to-add-border-for-an-image
\newcommand{\includegraphicsw}[2][1.]{\includegraphics[width=#1\linewidth]{#2}}
\newcommand{\svginput}[1]{\input{img/#1}} % pdf_tex path
\newcommand{\svginputw}[2][\linewidth]{\def\svgwidth{#1}\input{img/#2}} % pdf_tex path

% tables
\usepackage{longtable}
\usepackage{multirow}
\usepackage{hhline}
\usepackage{float} % for H

\newcommand{\cl}[1]{\texttt{\$~#1}}

\usepackage{listings}
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{10} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{10}  % for normal

% Custom colors
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\usepackage{listings}

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\ttm,
otherkeywords={self},             % Add keywords here
keywordstyle=\ttb\color{deepblue},
emph={MyClass,__init__},          % Custom highlighting
emphstyle=\ttb\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false            % 
}}


% Python environment
\lstnewenvironment{python}[1][]
{
\pythonstyle
\lstset{#1}
}
{} 
\newcommand\pythoninline[1]{{\pythonstyle\lstinline!#1!}}


% https://tex.stackexchange.com/questions/9425/how-to-fix-footnote-position-at-the-bottom-of-the-page
\usepackage[bottom]{footmisc}
\newcommand{\KW}[1]{{\color{blue}\textbf{KW}:~#1}}


\title{Evasion Path Persistence }
\author{
	Kyle Williams\thanks{Department of Mathematics, University of Houston, Houston, Texas 77204 (kylew@math.uh.edu).}
}


\begin{document}
	
\maketitle

\tableofcontents
\vfill
\clearpage
\let\oldtabular\tabular
\renewcommand{\tabular}[1][1.5]{\def\arraystretch{#1}\oldtabular}
\renewcommand\arraystretch{1.3}

\section{Code Structure}

This code currently contains the following classes:
\begin{itemize}
	\item {\bf CMap}: This class implements a combinatorial map used to find the boundary cycles.
	\item {\bf BoundaryInfo}: This class manages all info related to the boundary. If a new geometry for the domain were desired, ideally only this class would change.
	\item {\bf BrownianMotion}: This class handles all feature related to the generation and movement of the physical positions of the sensors. Ideally, changing the motion model for the sensors only requires changes to this class. This class is aware of the boundary data.
	\item {\bf EvasionPathSimulation}: This class manages the time stepping. Currently this is where the geometrical movements and the combinatorial features are combined to detect holes and track evasion paths.
	\item {\bf Animation}: Auxiliary class used to create animations of a given simulation.
\end{itemize}

\section{Combinatorial Map}
The only reason we implement the combinatorial map to begin with is in order to find the boundary cycles in a given complex. Because of this, the intended interface is rather small. The class represents the combinatorial map as a graph internally while also storing the geometric positions of the nodes of the graph.

 This module also provides a helper function to determine if a given boundary cycle (represented as a graph) is a {\it hole} or not. A hole in this code is defined as a cycle with more than 3 vertices that is not the boundary.

\subsection{Usage}
 In all that is desired is to find the boundary cycles, then one needs to only do the following:
 \begin{python}
 from combinatorial_map import *
 # Initialize the combinatorial map
 comb_map = CMap(G, points=points)
 boundary_cycles = comb_map.get_boundary_cycles()
 \end{python}
 Note that is is up to the user to ensure that (1) the number of graph nodes is the same as the number of points, and (2) that the nodes are numbered in the same way as the points. In the example given, the \pythoninline{boundary_cycles} returns a list of boundary cycles, each of which is represented by a list of darts. The boundary cycle darts are guaranteed to be a partition.  

A more useful representation for each of these boundary cycles is as a graph. To this end, the helper function \pythoninline{boundary_cycle_graphs()} is provided.
\begin{python}
 from combinatorial_map import *
 # Initialize the combinatorial map
 comb_map = CMap(G, points=points)
 bcycle_graphs = boundary_cycle_graphs(comb_map) 
 \end{python}
 In this example, \pythoninline{bcycle_graphs} is a list of \pythoninline{networkx} graphs.
 

There is also an option to initialize a combinatorial map directly with rotational data. This rotational data should be given as a list, with each element being itslef a list of orderd edges of a graph. For example, the rotation data fo Figure \ref{blah} would be constructed as follows
\begin{python}
	rotation_data = [ [], [], [], [], [] ]
	rotation_date[0] = [(0, 3), (0, 4), (0, 1), (0, 2)]
	rotation_data[1] = [(1, 0), (1, 2)]
	rotation_date[2] = [(2, 3), (2, 0), (2, 1)]
	rotation_data[3] = [(3, 4), (3, 0), (3, 2)]
	rotation_data[4] = [(4, 0), (4, 3)]
\end{python}
It is up to the user to ensure that this rotation data is correct and complete. 

\subsection{Implementation Details}

\section{GUDHI AlphaComplex}
We use the python wrappers for the GUDHI library %\cite{gudhi}. 
The usage of this library is rather minimal and described here. Full documentation can be found here %https://gudhi.inria.fr/python/latest/alpha\_complex\_user.html.

\begin{python}
from gudhi import AlphaComplex
from networkx import Graph
max_alpha_square = 2*sensing_radius

# Create Alpha Complex
alpha_complex = AlphaComplex(points)
simplex_tree = alpha_complex.create_simplex_tree(max_alpha_square)

# Get 1-simplices as edges for graph
edges = []
for simplex, _ in simplex_tree.get_skeleton(1):
	if len(simplex) == 2: edges.append(simplex)

# Use Edges to create graph
G = Graph()
G.add_nodes_from(range(N_points)))  # nodes numbered 0 though Npts - 1
G.add_edges_from(edges)
\end{python}
Here we are guaranteed that the maximum filtration value for any simplex is \pythoninline{max_alpha_square}. In particular, we can be sure that there are no 2-simplices with an edge with length greater than the set max filtration value. 

The 2-simplices can also be easily extracted for comparison
\begin{python}
from gudhi import AlphaComplex
max_alpha_square = 2*sensing_radius

# Create Alpha Complex
alpha_complex = AlphaComplex(points)
simplex_tree = alpha_complex.create_simplex_tree(max_alpha_square)

# Get 2-simplices
simplices2 = []
for simplex, _ in simplex_tree.get_skeleton(2):
	if len(simplex) == 3: simplices2.append(simplex)
\end{python}
\section{Boundary Info}
It was found to be convenient to have all boundary information packaged together in the same class. This makes it easy to check if a sensor is at the boundary, and to change the boundary easily if needed. This information is only needed by the Brownian Motion class; the only other place the boundary is needed is in detecting holes; but even then, only the node numbers are needed, not the boundary node positions. 


\section{Brownian Motion}
% \subsection{Usage}
% \subsection{Initial Point Generation}
% \subsection{Model}
% \subsection{Boundary Conditions}

\section{EvasionPathSimulation}
The idea for this class is that a single object is instantiated with given parameters, then a "run" function is called which iterates until there are no evasion paths returning the amount of time required to close all evasion paths. This should be able to be run in parallel to allow for several instantiations simultaneously Then do several hundreds of runs for a given set of parameters in order to retrieve statistical information. 
\subsection{Usage}
The class has a very minimal interface, we simply initialize the object with simulation parameters, and then run
\begin{python}
simulation = EvasionPathSimulation(dt=0.0001, end_time=0.01)
simulation.run()
\end{python}
\subsection{Implementation}
There are two function in this class, one that is essentially just a loop over time steps, and another that implements a single timesteps.

In a single timestep we do the following
\begin{enumerate}
\item Update sensor positions
\item Compute updated AlphaComplex
\item Extract Graph
\item Check that graph is connected
\item Build Combinatorial Map
\item Find holes
\item Determine possible Evasion Paths
\end{enumerate}

The program is currently set up for two different timestepping scenarios, (1) run until no more Evasion Paths, and (2) Run for fixed amount of time.

In the first case we have the following:
\begin{python}
while evasion_paths != []:
	time += dt
	do_timestep()
return time
\end{python}
Here we return the time taken for the evasion path to be closed. to select this option, initialize the simulation with \pythoninline{end_time = 0}. 

For the second case we have:
\begin{python}
while time < end_time:
	time += dt
	do_timestep()
if evasion_paths == []:
	return False
else:
	return True
\end{python}
In this case we return a boolian of wether the evasion path lasted for a given amount of time. To select this option, initialize the simulation with \pythoninline{end_time > 0}

\section{Evasion Path Detection}
\subsection{Find Hole}
Finding a hole has been included as a member function of the EvasionpathSimulation class because it requires knowledge of the graph, the Alpha Shape, as well as the Alpha Complex 2-simplices. In this code, a hole is defined as a boundary cycle with order greater than 3 and is not the alpha shape, or a boundary cycle with order 3 that is not a 2-simplex of the alpha shape. With this as a member function the only input parameter is the boundary cycle in question (represeted as a graph). We can then use the \pythoninline{is\_hole()} function in the following ways

 \begin{python}
 	from combinatorial_map import *
 	# Initialize the combinatorial map, points, and alpha_shape
 
	# Get boundary cycle graphs which are holes
	boundary_cycles = boundary_cycle_graphs(self.cmap)
   self.holes = list(filter(self.is_hole, boundary_cycles))
   
   # Assign true/false coloring to each boundary cycle
   boundary_cycles = boundary_cycle_graphs(self.cmap)
   self.cell_coloring = list(map(self.is_hole, boundary_cycles))
 
 \end{python}

The \pythoninline{is_hole()} function is crucial to this project so we present it here in full. This function checks if the alpha\_shape (boundary) is a subset of the graph, if so, then not a hole. It also check that it is not a simplex. If neither of these conditions are met, then the graph is deemed a {\it hole}.
\begin{python}
    def is_hole(graph):
        for simplex in simplices:
            if set(graph.nodes()) == set(simplex): 
              return False
        if set(alpha_shape).issubset(set(graph.nodes())):
            return False
        if graph.order >= 3:
            return True
\end{python}
It is important to note that two simplices are considered equal if they consist of the same vertices (without respect to any ordering).

So far, this program only implements the hole detection which is a key component in detecting evasion paths. It is able to detect (true/false) if a given face is a hole or not.

\section{Known Issues}
The known issues include the following:
\begin{itemize}
	\item If a node moves onto the boundary it seems to "get stuck" there and this incorrectly causes the boundary to be labeled as a hole. \KW{This particular problem seems to be fixed, but the boundary still flickers as a hole, then return to normal}
	\item \KW{Not sure how to exactly set the boundary sensor spacing} Boundary sensors will be spaced at $0.9*2*sensing_radius$. (Or possibly just $sensing\_radius$?
	\item \KW{If the a sensor gets to close to the boundary and the spacing is "large" , it distorts the boundary connectivity.}
	\item \KW{The code does not currently track evasion paths, but does find holes}
	\item \KW{Animations currently done manually in main.py}
\end{itemize}

\section{Experiments}
The experiments that will be run, will be somthing along the lines of the following:
\begin{itemize}
\item Set up a complex with a hole, and let the simulation run until all possible evasion paths have closed. This will be repeated enough times to infer statistics accurately. 
\item Set up a complex with a hole. Run the simulation for a fixed amount of time, and determine if there is an evasion path remaining at the end time. This will be repeated for several instances of a given time, and several choices of end time. 
\end{itemize}
Both of these experiments will be tested with independent variables including \pythoninline{boundary_radius}, \\ 
\pythoninline{sensing_radius}, 
\pythoninline{n_interior_sensors},
\pythoninline{dt}, 
\pythoninline{sigma} as well as the general form of the brownian motion model.




\section{Verification/Validation Tests}
So far tests have been mostly empirical. It is planned to add unit tests with known results to verify that all modules are working correctly. It is also planned to go back and write documentation using DOxygen and write a few example use cases as time permits.

\end{document}